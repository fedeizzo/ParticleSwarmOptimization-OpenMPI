<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSO - OpenMPI, OpenMP: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "Tex/Algorithm.sty.js", "Tex/Pseudocode.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    processEscapes: true
  }
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PSO - OpenMPI, OpenMP
   </div>
   <div id="projectbrief">A cooperant parallelized solution for Genetic Algorithm</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_report_01_introduction.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Introduction </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md13"></a>
Particle Swarm Optimization</h1>
<p >In order to deeply understand the reasons behind the report design choices, it is fundamental to understand comprehensively <em>Particle Swarm Optimization</em>.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Generalities</h2>
<p ><em>Particle Swarm Optimization</em> focuses on main definitions: the notion of <em>particle</em> and the one of <em>particle perception</em>.</p>
<p >A particle can be seen as an entity which is characterized by:</p>
<ul>
<li>a position $x$ depicting the <em>candidate solution</em> for our optimization problem;</li>
<li>a velocity component $v$, which is used in order to <em>perturb</em> the particle;</li>
<li>a performance measure $f(x)$, also called <em>fitness</em> value, which quantify the quality of the candidate solution.</li>
</ul>
<p >The entire set of particles is referred as <em>swarm</em>.</p>
<p >Under the expression <em>particle perception</em>, we define how each particle communicate with each other. In practice, a particle needs to perceive the positions along with the associated performance measures of the <em>neighboring particles</em>. Thanks to this communication pattern, each particle remembers the position $z$ associated to the best performance of all the particles within the neighborhood, as well as its own position where it obtained the best performance so far $y$.</p>
<p >There are different structures of neighborhood which can be considered, and they usually depend on the type of optimization problem one has to face.</p>
<p >The most relevant types of neighborhood are:</p>
<ul>
<li><em>Global</em>: the best individual in the neighborhood is also the <em>global</em> best in the entire swarm;</li>
<li><em>Distance-based</em>: based on a proximity metric (e.g. euclidean distance);</li>
<li><em>List-based</em>: based on a predetermined topology arranging the solution indexes according to some order or structure, and a given neighborhood size.</li>
</ul>
<div class="image">
<img src="particle_neighborhood.png" alt=""/>
<div class="caption">
Different neighborhood structures in PSO</div></div>
   <p >This project implements a version of PSO considering <em>distance-based</em> neighborhood in a nearest neighbor fashion. In details, each particle has a fixed number of neighbors, which depend dynamically on the particle position on the landscape. The program offers the user the possibility to modify the number of particles to consider within a particle neighborhood.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Parametrization</h2>
<p >In order to assess a solution for an optimization problem, PSO requires the following parameters ot be set:</p>
<ul>
<li><em>Swarm size</em>: typically 20 particles for problems with dimensionality 2-200;</li>
<li><em>Neighborhood size</em>: typically 3 to 5, otherwise global neighborhood;</li>
<li><em>Velocity update factors</em>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md16"></a>
Continuous Optimization</h2>
<p >Once the algorithm has been parametrized, a swarm of particles is initialized with random positions and velocity.</p>
<p >At each step, each particle updates first its velocity:</p>
<p >$$v' = w \cdot v + \phi_1 U_1 \cdot (y-x) + \phi_2 U_2 \cdot (z-x)$$</p>
<p >where:</p>
<ul>
<li>$x$ and $v$ are the particle current position and velocity, respectively;</li>
<li>$y$ and $z$ are the personal and social/global best position, respectively;</li>
<li>$w$ is the inertia (weighs the current velocity);</li>
<li>$\phi_1$, $\phi_2$ are acceleration coefficients/learning rates (cognitive and social, respectively);</li>
<li>$U_1$ and $U_2$ are uniform random numbers in $[0,1]$.</li>
</ul>
<p >Finally, each particle updates its position:</p>
<p >$$x' = x+v'$$</p>
<p >and in case of improvement, update $y$ (and eventually $z$).</p>
<p >The loop is iterated until a given stop condition is met.</p>
<p >The pseudocode of the algorithm is shown below:</p>
<p >\begin{algorithm}[H] \caption{Initialize} \begin{algorithmic}[1] \Procedure{Initialize}{$\mathcal{S}$, $\mathcal{D}$, $f$, $v$, $x$, $x_{min}$, $x_{max}$, $v_{max}$} \ForAll {particle $i \in \mathcal S$} \ForAll {dimension $d \in \mathcal D$} \State $x_{i, d} \gets Rnd(x_{min}, x_{max})$ \Comment{Initialize the particles' positions} \State $v_{i, d} \gets Rnd(-v_{max}/3, v_{max}/3)$ \Comment{Initialize the particles' velocity} \EndFor \EndFor</p>
<p >\State $pb_i \gets x_i$ \Comment{Initialize the particle best position} \State $gb_i \gets x_i$ \Comment{Update the particle's best position} \EndProcedure \end{algorithmic} \end{algorithm}</p>
<p >\begin{algorithm}[H] \caption{Particle Swarm Optimization (Nearest Neighbors)} \begin{algorithmic}[1] \Function{PSO}{$\mathcal{S}$, $\mathcal{D}$, $MAX_IT$, $n$, $f$, $v$, $x$, $x_{min}$, $x_{max}$, $v_{max}$}</p>
<p >\State \Call{Initialize}{$\mathcal{S}$, $\mathcal{D}$, $f$, $v$, $x$, $x_{min}$, $x_{max}$, $v_{max}$} \Comment{Initialize all the particles}</p>
<p >\State $it = 0$ \Repeat \ForAll {particle $i \in \mathcal{S}$} \If{$f(x_{i}) &lt; f(pb_{i})$} \State $pb_{i} \gets x_{i}$ \Comment{Update the particles' best position} \EndIf \EndFor \State $\mathcal{S'} = $ \Call{Copy}{$\mathcal{S}$} \Comment{Copy the particle's vector} \ForAll {particle $i \in \mathcal S$} \State $\mathcal{S'}$ = \Call{Sort}{S', i} \Comment{Sort the particles w.r.t. $i$th particle} \ForAll {particle $j \in \mathcal{S'}$} \If{$f(x_j) &lt; f(gb_{i})$} \State $gb_i \gets x_j$ \EndIf \EndFor \EndFor \ForAll {particle $i \in \mathcal S$} \ForAll {dimension $d \in \mathcal D$} \State $v_{i, d} = v_{i, d} + C_1 \cdot Rnd(0, 1) \cdot [pb_{i, d} - x_{i, d}] + C_2 \cdot Rnd(0, 1) \cdot [gb_{d} - x_{i, d}]$ \State $x_{i, d} = x_{i, d} + v_{i, d}$ \Comment{Update the velocity and positions} \EndFor \EndFor \State $it \gets it + 1$ \Comment{Advance iteration} \Until{it $&lt;$ MAX_ITERATIONS} \State \Return x \EndFunction \end{algorithmic} \end{algorithm}</p>
<h1><a class="anchor" id="autotoc_md17"></a>
MPI</h1>
<p >The MPI (Message Passing Interface) library is used to convey information across processes running on different nodes of a cluster.</p>
<p >In the scenario described by the application, the basic information unit is composed as a broadcast message shared over the whole network, in this way all particles of Particle Swarm Optimization (PSO) are able to know all information associated to other members of the swarm.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
OpenMP</h1>
<p >OpenMP is an API which supports multi-platform shared memory programming.</p>
<p >In the program scenario, a process is delegated to handle the computing regarding one or more particles. The process job is divided in several threads which optimize the execution time of the process.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Project generalities</h1>
<p >In the following sections, the report address how to setup and run the program.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Libraries</h2>
<p >The project requires few libraries in order to work properly. As it is mandatory for the course, <a href="https://www.openmp.org/">OpenMP</a> and <a href="https://www.open-mpi.org/">MPI</a> were employed. Along with the compulsory libraries, the following libraries were exploited:</p>
<ul>
<li><a href="https://www.sqlite.org/index.html">sqlite</a>: SQLite is a C-language library that provides a SQL database engine that is tiny, quick, self-contained, high-reliability, and full-featured. The choice of <code>sqlite</code> was made in order to save particles' information at each iteration in an simple and fast way, avoiding dealing with race conditions.</li>
<li><a href="https://www.gnu.org/software/libc/manual/html_node/Argp.html">argp</a>: <code>argp</code> is a parsing interface for unix-style argument vectors. The argp features include, as defined in the GNU coding standards, automatically producing output in response to the <code>--help</code> and <code>--version</code> options and the possibility for programmers to explicitly define the input of the script. This library was employed in order to allow the user to explore the possible configurations made available by the software.</li>
<li><a href="https://libcheck.github.io/check/">check</a>: <code>check</code> is a unit testing framework written in C. It has a straightforward interface for defining unit tests helping the developer to build robust software. This library was included in the application in order to perform unit-testing on the structure we have created. This choice implication are a more robust software.</li>
</ul>
<h2><a class="anchor" id="autotoc_md21"></a>
Build</h2>
<p >In order to build the executable file of our project, as well as the binary file needed to run the project unit test, we have employed <a href="https://www.gnu.org/software/make/">GNU Make</a>.</p>
<p >GNU Make is a tool which manages the creation of executables and other non-source files from a program's source files. Make learns how to create your software using a file called the <code>Makefile</code>, which lists each non-source file and how to compute it from other files.</p>
<p >Thanks to the definitions of rules, Make enables the user to build and install packages without knowing the details on how that is done.</p>
<p >Moreover, thanks to wildcards, it is easy to automatize the application building process. Indeed, it first allow to assemble each <code>C</code> source file in order to create the object files. Then, all of the object files are linked together, along with other libraries, in order to produce the final executable file. If the building rule is called multiple times, Make is smart enough to understand whether an object file needs to be recreated or not, making use of the already assembled objects, thus speeding up the building process.</p>
<p >Furthermore, Make can do much more than compiling software, for instance, the project contains rules which allow to build and open the code documentation written by the means of <a href="https://doxygen.nl/">Doxygen</a>.</p>
<p >In order to get the right flag for linking the needed external, the project employs <a href="https://people.freedesktop.org/~dbn/pkg-config-guide.html">pkg-config</a>. This package collects metadata about the installed libraries on the system and easily provides it to the user. Hence, <code>pkg-config</code> takes care of where a library is located regardless of the distribution simplifying the application building process.</p>
<h3><a class="anchor" id="autotoc_md22"></a>
Compile</h3>
<p >To compile the project, it is possible to call the Makefile by typing:</p>
<div class="fragment"><div class="line">make build</div>
</div><!-- fragment --><p >In this way, the executable <code>bin/particle-swarm-optimization</code> is ready to be launched.</p>
<p >Instead, to build the unittest, it is possible to execute the following command.</p>
<div class="fragment"><div class="line">make test</div>
</div><!-- fragment --><p >The artifact is located in the <code>bin</code> directory and it is called <code>test</code>.</p>
<p >Along with the executable files, there are also scripts used in order to run the program within the University cluster. Each job in the cluster is handled by <em>PBS (Portable Bash Script)</em> which submits them to the scheduler. By means of a script, it is possible to tell the scheduler what resources the job requires in order to complete (e.g. number of processors, amount of memory, time to complete etc.) and the application the user wants to run.</p>
<p >The <code>run.sh</code> file in the <code>scripts</code> folder of the repository allows the user to submit the application to the cluster. The script has three parameters: number of processes, path of the ini file containing the program configuration and the number of threads. Once submitted with the <code>qsub</code> command, the script generates a number of docker containers equal to the number of specified processes thanks to the <code>mpiexec</code> binary. Each container runs the application in a shared network, therefore each process is able to communicate with each other. The details of the program deployment is discussed in the section dedicated to DevOps.</p>
<p >The <code>generate_cluster_run.sh</code> file, contained in the <code>scripts</code> folder, is employed in order to generate specific runs in order to benchmark the application. In details, the shell file considers several combinations of processes, threads, nodes and places. More details are provided in the section dedicated to the application benchmark.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Execute</h2>
<p >The executable file can be invoked with or without <code>OpenMP</code> and with or without <code>OpenMPI</code>. However, to fully exploit <code>OpenMPI</code>, it is recommended to execute the program <code>mpiexec</code> to spawn multiple processes of the multi-process application.</p>
<p >The executable file requires several arguments. Below there is an excerpt of the program output when the <code>--help</code> flag is called.</p>
<div class="fragment"><div class="line">A Cooperating parallelized solution for Genetic Algorithm. A tool that takes a set of continuous or discrete variables and an optimization</div>
<div class="line">problem designed to work with them. The goal is to find the optimal solution by</div>
<div class="line">exploiting Genetic Algorithms and the computational power offered by the cluster</div>
<div class="line"> </div>
<div class="line">  -m, --number-of-threads[=COUNT]</div>
<div class="line">                             Number of threads for process</div>
<div class="line">  -u, --use-openmpi          Use OpenMPI</div>
<div class="line">  -?, --help                 Give this help list</div>
<div class="line">      --usage                Give a short usage message</div>
<div class="line">  -V, --version              Print program version</div>
</div><!-- fragment --><p >In order to run, the application requires three parameters, two which are optional, while one is mandatory.</p>
<p >The compulsory parameter is the configuration file, which needs to be provided in an <code>INI file</code>. This file, takes care of all the parameters which are needed by the Particle Swarm Optimization algorithm to run and which have been fully discussed during the introduction to the problem. The repository provides a standard <code>INI</code> file, called <code>pso-data.ini</code>, which can be modified in order to configure algorithm so as to solve the target problem.</p>
<p >It is possible to specify the number of threads the program is allowed to spawn with the <code>-m</code> flag, and whether to employ <code>MPI</code> primitives or not with the <code>-u</code> flag. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
